<script setup lang="ts">
/**
 * Entity property value renderer that automatically infers the best renderer for the given type of value.
 */

import {
    EntityPropertyValueSupportedCodeLanguage
} from '@/modules/entity-viewer/viewer/model/entity-property-value/EntityPropertyValueSupportedCodeLanguage'
import { EntityPropertyValue } from '@/modules/entity-viewer/viewer/model/EntityPropertyValue'
import { Scalar } from '@/modules/connection/model/data-type/Scalar'
import { ExtraEntityObjectType } from '@/modules/entity-viewer/viewer/model/ExtraEntityObjectType'
import { computed } from 'vue'
import { NativeValue } from '@/modules/entity-viewer/viewer/model/entity-property-value/NativeValue'
import CodeDetailRenderer
    from '@/modules/entity-viewer/viewer/component/entity-grid/detail-renderer/CodeDetailRenderer.vue'
import HtmlDetailRenderer
    from '@/modules/entity-viewer/viewer/component/entity-grid/detail-renderer/HtmlDetailRenderer.vue'
import MarkdownDetailRenderer
    from '@/modules/entity-viewer/viewer/component/entity-grid/detail-renderer/MarkdownDetailRenderer.vue'
import PricesDetailRenderer
    from '@/modules/entity-viewer/viewer/component/entity-grid/detail-renderer/PricesDetailRenderer.vue'
import ReferenceAttributesDetailRenderer
    from '@/modules/entity-viewer/viewer/component/entity-grid/detail-renderer/ReferenceAttributesDetailRenderer.vue'

/**
 * Used to decide whether XML is actually HTML5.
 * Basic HTML5 tags sorted from the most used generated by ChatGTP.
 */
const htmlTags = [
    '<div', '<a', '<p', '<span', '<ul', '<li', '<img', '<h1',
    '<h2', '<h3', '<input', '<body', '<html', '<head', '<title',
    '<meta', '<link', '<style', '<script', '<br', '<ol', '<h4',
    '<h5', '<h6', '<i', '<b', '<form'
];

enum RendererType {
    Markdown = 'markdown',
    Code = 'code',
    Html = 'html',
    Price = 'price',
    ReferenceAttribute = 'referenceAttribute'
}
type ResolvedRenderer = {
    type: RendererType,
}
type CodeRenderer = ResolvedRenderer & {
    codeLanguage: EntityPropertyValueSupportedCodeLanguage
}
type ValueToRender = {
    renderer: ResolvedRenderer,
    value: EntityPropertyValue | EntityPropertyValue[]
}

const props = withDefaults(defineProps<{
    dataType: Scalar | ExtraEntityObjectType | undefined,
    value: EntityPropertyValue | EntityPropertyValue[],
    fillSpace?: boolean
}>(), {
    fillSpace: true
})

const valueToRender = computed<ValueToRender>(() => {
    const valueToRender: ValueToRender = {} as ValueToRender
    if (!props.dataType) {
        valueToRender.renderer = {
            type: RendererType.Code,
            codeLanguage: EntityPropertyValueSupportedCodeLanguage.Raw
        } as CodeRenderer
        valueToRender.value = new NativeValue(props.value instanceof Array ? `[${props.value.map(item => item.toPreviewString()).join(', ')}]` : (props.value as EntityPropertyValue).toPreviewString())
    } else {
        switch (props.dataType) {
            case Scalar.String: {
                const stringValue: string = ((props.value as EntityPropertyValue).value() as string).trim()
                if (stringValue.startsWith('{') || stringValue.startsWith('[')) {
                    // probably JSON
                    valueToRender.renderer = {
                        type: RendererType.Code,
                        codeLanguage: EntityPropertyValueSupportedCodeLanguage.Json
                    } as CodeRenderer
                    valueToRender.value = props.value
                } else if (stringValue.startsWith('<')) {
                    if (hasHtmlTag(stringValue)) {
                        // probably HTML5
                        valueToRender.renderer = {
                            type: RendererType.Html
                        }
                    } else {
                        // probably base XML
                        valueToRender.renderer = {
                            type: RendererType.Code,
                            codeLanguage: EntityPropertyValueSupportedCodeLanguage.Xml
                        } as CodeRenderer
                    }
                    valueToRender.value = props.value
                } else {
                    // regular text or something we don't support yet
                    valueToRender.renderer = {
                        type: RendererType.Markdown
                    }
                    valueToRender.value = props.value
                }
                break
            }
            case Scalar.ComplexDataObject:
                valueToRender.renderer = {
                    type: RendererType.Code,
                    codeLanguage: EntityPropertyValueSupportedCodeLanguage.Json
                } as CodeRenderer
                valueToRender.value = props.value
                break
            case ExtraEntityObjectType.Prices:
                valueToRender.renderer = {
                    type: RendererType.Price
                }
                valueToRender.value = props.value
                break
            case ExtraEntityObjectType.ReferenceAttributes:
                valueToRender.renderer = {
                    type: RendererType.ReferenceAttribute
                }
                valueToRender.value = props.value
                break
            default:
                valueToRender.renderer = {
                    type: RendererType.Markdown
                }
                valueToRender.value = props.value
                break
        }
    }
    return valueToRender
})

function hasHtmlTag(s: string): boolean {
    for (const htmlTag of htmlTags) {
        if (s.includes(htmlTag)) {
            return true
        }
    }
    return false
}

</script>

<template>
    <MarkdownDetailRenderer
        v-if="valueToRender.renderer.type === RendererType.Markdown"
        :value="valueToRender.value"
        :data-type="dataType"
    />
    <CodeDetailRenderer
        v-else-if="valueToRender.renderer.type === RendererType.Code"
        :value="valueToRender.value"
        :code-language="(valueToRender.renderer as CodeRenderer).codeLanguage"
    />
    <HtmlDetailRenderer
        v-else-if="valueToRender.renderer.type === RendererType.Html"
        :value="valueToRender.value"
    />
    <PricesDetailRenderer
        v-else-if="valueToRender.renderer.type === RendererType.Price"
        :value="valueToRender.value"
    />
    <ReferenceAttributesDetailRenderer
        v-else-if="valueToRender.renderer.type === RendererType.ReferenceAttribute"
        :value="valueToRender.value"
    />
</template>

<style lang="scss" scoped>

</style>
