{
  "app": {
    "name": "evitaLab"
  },
  "common": {
    "placeholder": {
      "empty": "<empty>",
      "emptyArray": "<empty array>",
      "null": "<null>",
      "yes": "Yes",
      "no": "No"
    },
    "button": {
      "close": "Close",
      "cancel": "Cancel",
      "remove": "Remove",
      "save": "Save",
      "run": "Run",
      "add": "Add",
      "create": "Create",
      "drop": "Drop",
      "executeQuery": "Execute query",
      "showMore": "Show more",
      "copy": "Copy",
      "confirm": "Confirm",
      "rename": "Rename",
      "replace": "Replace",
      "switch": "Switch"
    },
    "notification": {
      "copiedToClipboard": "Copied to clipboard",
      "failedToCopyToClipboard": "Failed to copy to clipboard"
    },
    "list": {
      "empty": "No items found."
    },
    "codeEditor": {
      "status": {
        "cursorPosition": "Ln {line}, Col {column}",
        "selectionRange": "{charsCount} chars",
        "selectionRanges": "{linesCount} line breaks"
      }
    },
    "dialog": {
      "confirmDialog": {
        "title": "Dangerous operation",
        "message": "Warning! You are about to do dangerous operation. Are you sure you want to proceed?"
      }
    }
  },
  "panel": {
    "manage": {
      "manage": {
        "title": "Manage",
        "item": {
          "keymap": "Keymap"
        }
      },
      "evitaLabHelp": {
        "title": "evitaLab Help",
        "item": {
          "evitaLabGithub": "evitaLab GitHub",
          "discussEvitaLab": "Discuss evitaLab",
          "reportEvitaLabIssue": "Report evitaLab issue"
        }
      },
      "evitaDBHelp": {
        "title": "evitaDB Help",
        "item": {
          "evitaDBDocumentation": "evitaDB Documentation",
          "evitaDBGithub": "evitaDB GitHub",
          "discussEvitaDB": "Discuss evitaDB",
          "reportEvitaDBIssue": "Report evitaDB issue"
        }
      }
    },
    "item": {
      "explorer": "Explorer"
    },
    "link": {
      "evitaDBDocumentation": {
        "icon": {
          "alt": "evitaDB Documentation"
        },
        "tooltip": "Open evitaDB documentation"
      },
      "discord": {
        "icon": {
          "alt": "Discord"
        },
        "tooltip": "Discuss on Discord"
      }
    }
  },
  "welcomeScreen": {
    "changelog": "changelog",
    "description": "evitaDB web client",
    "blog": {
      "thumbnail": {
        "alt": "Image - {title}"
      },
      "button": {
        "read": "Read"
      }
    },
    "link": {
      "evitaDBDocumentation": {
        "text": "Check out the {link}",
        "link": "evitaDB documentation"
      },
      "evitaLabGitHub": {
        "text": "Give us a ⭐ on {link}",
        "link": "GitHub"
      },
      "discord": {
        "text": "Reach out to us on {link}",
        "link": "Discord"
      },
      "submitIssue": "Submit an issue"
    }
  },
  "tab": {
    "button": {
      "closeTab": "Close tab"
    },
    "placeholder": {
      "loading": "Loading, please wait ..."
    }
  },
  "tabShare": {
    "button": {
      "shareTab": "Share this tab"
    },
    "tooltip": {
      "nonSharableTab": "Cannot share this tab because it is using a user-defined evitaDB connection. Only pre-configured connections can be shared."
    },
    "sharedDialog": {
      "title": "Shared tab found",
      "text": {
        "withoutInitialData": "The URL contains an embedded query from an unknown source. Do you want to open it? If you accept, evitaLab will <em>open a new tab</em> with the query, but will <em>not</em> execute it automatically. You can still decide if you want to execute it. If you reject, the query in the URL will be <em>discarded</em>.",
        "withInitialData": "The URL contains an embedded shared tab from an unknown source. Do you want to open it? If you accept it, evitaLab will <em>open a new tab</em> with the query. If you reject it, it will be <em>discarded</em>."
      },
      "warning": {
        "potentiallyUnsafe": "<em>Be careful!</em> The query in the URL may contain potentially malicious code."
      },
      "button": {
        "reject": "Reject",
        "accept": "Accept"
      }
    },
    "shareDialog": {
      "title": "Share this tab",
      "text": "You can share this tab and its data with other users via a link. This link will open a new instance of evitaLab on their device and load this tab with the same query, which should give the same output as you see now.",
      "notification": {
        "linkCopied": "Link copied to clipboard."
      },
      "warning": {
        "sensitiveData": "Be <em>careful</em> if you have sensitive data in the query, you are giving them away embedded in the link. Once you send the link, you lose control over it and it can be opened by <em>anyone</em> who has access to this evitaLab instance.",
        "linkMayNotWork": "The link may <em>not</em> work in certain browsers due to its length exceeding {{ urlCharacterLimit }} characters."
      },
      "button": {
        "copyLink": "Copy link"
      }
    }
  },
  "command": {
    "system": {
      "_title": "System",
      "keymap": "Keymap",
      "panels": {
        "_title": "Panels",
        "connectionsExplorer": "Explorer"
      },
      "editor": {
        "_title": "Editor",
        "previousTab": "Previous tab",
        "nextTab": "Next tab",
        "closeTab": "Close tab",
        "closeAllTabs": "Close all tabs"
      }
    },
    "queryEditor": {
      "_title": "Query editor",
      "moveLineUp": "Move line up",
      "moveLineDown": "Move line down",
      "copyLineUp": "Copy line up",
      "copyLineDown": "Copy line down",
      "simplifySelection": "Simplify selection",
      "selectLine": "Select line",
      "selectParentSyntax": "Select parent syntax",
      "indentLess": "Indent less",
      "indentMore": "Indent more",
      "indentSelection": "Indent selection",
      "deleteLine": "Delete line",
      "cursorMatchingBracket": "Cursor matching bracket",
      "toggleComment": "Toggle comment",
      "toggleBlockComment": "Toggle block comment"
    },
    "inlineQueryEditor": {
      "_title": "Inline query editor",
      "openHistory": "Open history"
    },
    "entityViewer": {
      "_title": "Entity grid",
      "executeQuery": "Execute query",
      "changeQueryLanguage": "Change query language",
      "filterBy": "Filter by",
      "orderBy": "Order by",
      "changeDataLocale": "Change data locale",
      "changePriceType": "Change price type",
      "shareTab": "Share tab",
      "openPropertySelector": "Open property selector",
      "propertySelector": {
        "_title": "Property selector",
        "findProperty": "Find property"
      }
    },
    "evitaQLConsole": {
      "_title": "evitaQL console",
      "executeQuery": "Execute query",
      "shareTab": "Share tab",
      "query": {
        "_title": "Query",
        "queryEditor": "Query editor",
        "variablesEditor": "Variables editor",
        "history": "History"
      },
      "result": {
        "_title": "Result",
        "rawResultViewer": "Raw result viewer",
        "resultVisualizer": "Result visualizer"
      }
    },
    "graphQLConsole": {
      "_title": "GraphQL console",
      "executeQuery": "Execute query",
      "shareTab": "Share tab",
      "query": {
        "_title": "Query",
        "queryEditor": "Query editor",
        "variablesEditor": "Variables editor",
        "history": "History",
        "schemaViewer": "Schema viewer"
      },
      "result": {
        "_title": "Result",
        "rawResultViewer": "Raw result viewer",
        "resultVisualizer": "Result visualizer"
      }
    },
    "schemaViewer": {
      "_title": "Schema viewer",
      "shareTab": "Share tab"
    }
  },
  "explorer": {
    "title": "Connections Explorer",
    "button": {
      "addConnection": "Add connection"
    },
    "connection": {
      "actions": {
        "refresh": "Refresh",
        "openGraphQLSystemApiConsole": "Open GraphQL System API console",
        "add": "Add connection",
        "create": "Create catalog",
        "edit": "Edit connection",
        "remove": "Remove connection",
        "detail": "Status",
        "createCatalog": "Create catalog",
        "tasks": "Tasks",
        "jfrRecordings": "JFR recordings"
      },
      "subheader": {
        "catalogs": "Catalogs"
      },
      "editor": {
        "addTitle": "Add connection",
        "editTitle": "Edit connection",
        "form": {
          "connectionName": {
            "label": "Connection name",
            "validations": {
              "required": "Name of connection is required.",
              "duplicate": "Connection with this name already exists."
            }
          },
          "systemApiUrl": {
            "label": "System API URL",
            "validations": {
              "required": "System API URL is required.",
              "invalidUrl": "System API URL is not a valid URL.",
              "unreachable": "System API URL is not reachable."
            }
          },
          "grpcUrl": {
            "label": "gRPC API URL",
            "validations": {
              "required": "gRPC API URL is required.",
              "invalidUrl": "gRPC API URL is not a valid URL.",
              "unreachable": "gRPC API URL is not reachable."
            }
          },
          "graphQLApiUrl": {
            "label": "GraphQL API URL",
            "validations": {
              "required": "GraphQL API URL is required.",
              "invalidUrl": "GraphQL API URL is not a valid URL.",
              "unreachable": "GraphQL API URL is not reachable."
            }
          },
          "observability": {
            "label": "Observability API URL",
            "validations": {
              "required": "Observability API URL is required.",
              "invalidUrl": "Observability API URL is not a valid URL.",
              "unreachable": "Observability API URL is not reachable."
            }
          }
        },
        "notification": {
          "connectionSuccess": "Successfully connected.",
          "connectionError": "Connection test failed.",
          "connectionAdded": "The {connectionName} connection has been successfully added.",
          "connectionEdited": "The {connectionName} connection was successfully edited.",
          "couldNotAddConnection": "Could not add the connection: {reason}",
          "couldNotEditConnection": "Could not edit the connection: {reason}"
        }
      },
      "remove": {
        "title": "Remove connection",
        "question": "Do you want to remove {connectionName} connection?",
        "notification": {
          "connectionRemoved": "The {connectionName} connection has been successfully removed.",
          "couldNotRemoveConnection": "Could not remove the {connectionName} connection: {reason}"
        }
      }
    },
    "catalog": {
      "subheader": {
        "modify": "Modify",
        "collections": "Collections",
        "backup": "Backup"
      },
      "actions": {
        "openEvitaQLConsole": "Open evitaQL console",
        "openGraphQLDataApiConsole": "Open GraphQL Data API console",
        "openGraphQLSchemaApiConsole": "Open GraphQL Schema API console",
        "viewSchema": "View schema",
        "dropCatalog": "Drop catalog",
        "renameCatalog": "Rename catalog",
        "replaceCatalog": "Replace catalog",
        "createCollection": "Create collection",
        "switchCatalogToAliveState": "Switch catalog to alive state",
        "backup": "Backups"
      },
      "errors": {
        "couldNotLoad": "This catalog couldn't be loaded because it's corrupted."
      },
      "create": {
        "title": "Create catalog",
        "description": "Create a new catalog:",
        "form": {
          "catalogName": {
            "label": "Catalog name",
            "validations": {
              "required": "Catalog name is required.",
              "empty": "Catalog name is required.",
              "leadingTrailingWhiteSpace": "Catalog name cannot have leading or trailing whitespace characters.",
              "keyword": "Catalog name is same as a reserved keyword.",
              "format": "Catalog name doesn't match supported format.",
              "notAvailable": "Catalog with this name already exists."
            }
          }
        },
        "notification": {
          "catalogCreated": "The {catalogName} catalog has been successfully created.",
          "couldNotCreateCatalog": "Could not create the {catalogName} catalog: {reason}"
        }
      },
      "drop": {
        "title": "Drop catalog",
        "question": "Do you want to drop {catalogName} catalog?",
        "notification": {
          "catalogDropped": "The {catalogName} catalog has been successfully dropped.",
          "catalogNotDropped": "The {catalogName} catalog has been already dropped.",
          "couldNotDropCatalog": "Could not drop the {catalogName} catalog: {reason}"
        }
      },
      "rename": {
        "title": "Rename catalog",
        "description": "Rename catalog {catalogName} to:",
        "form": {
          "newName": {
            "label": "New name",
            "validations": {
              "required": "New name is required.",
              "empty": "New name is required.",
              "leadingTrailingWhiteSpace": "New name cannot have leading or trailing whitespace characters.",
              "keyword": "New name is same as a reserved keyword.",
              "format": "New name doesn't match supported format.",
              "notAvailable": "Catalog with this new name already exists."
            }
          }
        },
        "notification": {
          "catalogRenamed": "The {catalogName} catalog has been successfully renamed to {newName}.",
          "catalogNotRenamed": "The {catalogName} catalog has not been renamed.",
          "couldNotRenameCatalog": "Could not rename catalog {catalogName}: {reason}"
        }
      },
      "replace": {
        "title": "Replace catalog",
        "description": "Replace {catalogNameToBeReplaced} catalog with:",
        "info": "The {catalogNameToBeReplaced} catalog's data will be replaced with a data from the {catalogNameToBeReplacedWith} catalog under the {catalogNameToBeReplaced} name. The {catalogNameToBeReplacedWith} catalog will be deleted.",
        "form": {
          "catalogNameToBeReplacedWith": {
            "label": "Source catalog",
            "validations": {
              "required": "Catalog is required.",
              "notExists": "This catalog doesn't exist anymore."
            }
          }
        },
        "notification": {
          "catalogReplaced": "The {catalogNameToBeReplaced} catalog has been successfully replaced with {catalogToBeReplacedWith}.",
          "catalogNotReplaced": "The {catalogNameToBeReplaced} catalog has not been replaced.",
          "couldNotReplaceCatalog": "Could not replace the {catalogNameToBeReplaced} catalog: {reason}"
        }
      },
      "switchToAliveState": {
        "title": "Switch catalog to alive state",
        "description": "Switch the {catalogName} catalog from the warm up state to the alive state.",
        "warning": "Catalog in the alive state will no longer support bulk indexing. Instead, the catalog will use incremental indexing. However, it will support transactions and multiple parallel sessions.",
        "notification": {
          "catalogSwitched": "The {catalogName} catalog has been switched from the warm up state to the alive state.",
          "catalogNotSwitched": "The {catalogName} catalog has not been switched to alive state. Probably it already is in the alive state.",
          "couldNotSwitchCatalog": "Could not switch the {catalogName} catalog to the alive state: {reason}"
        }
      }
    },
    "collection": {
      "subheader": {
        "modify": "Modify"
      },
      "actions": {
        "viewEntities": "View entities",
        "viewSchema": "View schema",
        "dropCollection": "Drop collection",
        "renameCollection": "Rename collection"
      },
      "create": {
        "title": "Create collection",
        "description": "Create a collection for the {catalogName} catalog:",
        "form": {
          "entityType": {
            "label": "Entity type",
            "validations": {
              "required": "Entity type is required.",
              "empty": "Entity type is required.",
              "leadingTrailingWhiteSpace": "Entity type cannot have leading or trailing whitespace characters.",
              "keyword": "Entity type is same as a reserved keyword.",
              "format": "Entity type doesn't match supported format.",
              "notAvailable": "Collection with this entity type already exists."
            }
          }
        },
        "notification": {
          "collectionCreated": "The {entityType} collection has been successfully created.",
          "couldNotCreateCollection": "Could not create the {entityType} collection: {reason}"
        }
      },
      "drop": {
        "title": "Drop collection",
        "question": "Do you want to drop the {entityType} collection?",
        "notification": {
          "collectionDropped": "The {entityType} collection has been successfully dropped.",
          "collectionNotDropped": "The {entityType} collection has been already dropped.",
          "couldNotDropCollection": "Could not drop the {entityType} collection: {reason}"
        }
      },
      "rename": {
        "title": "Rename collection",
        "description": "Rename the {entityType} collection to:",
        "form": {
          "newName": {
            "label": "New name",
            "validations": {
              "required": "New name is required.",
              "empty": "New name is required.",
              "leadingTrailingWhiteSpace": "New name cannot have leading or trailing whitespace characters.",
              "keyword": "New name is same as a reserved keyword.",
              "format": "New name doesn't match supported format.",
              "notAvailable": "Collection with this new name already exists."
            }
          }
        },
        "notification": {
          "collectionRenamed": "The {entityType} collection has been successfully renamed to {newName}.",
          "collectionNotRenamed": "The {entityType} collection has not been renamed.",
          "couldNotRenameCollection": "Could not rename the {entityType} collection: {reason}"
        }
      }
    }
  },
  "entityViewer": {
    "loadedDataWarning": "Loaded query data must be manually executed.",
    "dataLocaleSelector": {
      "item": {
        "none": "None"
      }
    },
    "priceTypeSelector": {
      "WITH_TAX": "With tax",
      "WITHOUT_TAX": "Without tax"
    },
    "queryInput": {
      "notification": {
        "failedToSaveQueryToHistory": "Failed to save query to history."
      }
    },
    "propertySelector": {
      "title": "Displayed properties",
      "label": {
        "filterProperties": "Filter properties"
      },
      "button": {
        "selectDisplayedProperties": "Select displayed properties"
      },
      "notification": {
        "invalidPropertySectionSelection": "Cannot select `Some` properties in a section."
      },
      "section": {
        "type": {
          "entity": "Entity",
          "attributes": "Attributes",
          "associatedData": "Associated data",
          "references": "References",
          "referenceAttributes": "Reference attributes",
          "prices": "Prices"
        },
        "button": {
          "openSchema": "Open schema"
        },
        "placeholder": {
          "noItemsForSearchedTerm": "No items found for searched term."
        }
      }
    },
    "grid": {
      "notification": {
        "failedToFindProperty": "Failed to find property descriptor for key: '{key}'",
        "failedToFindRequestedProperties": "These properties were requested but not found in current data: {keys}"
      },
      "cell": {
        "placeholder": {
          "noLocaleSelected": "<no locale selected>"
        },
        "detail": {
          "placeholder": {
            "invalidValue": "Invalid value.",
            "unknownProperty": "Unknown property"
          }
        }
      },
      "renderer": {
        "button": {
          "displayRawValue": "Display raw value",
          "prettyPrintValue": "Pretty print value",
          "selectOutputFormat": "Select output format"
        },
        "format": {
          "autoPrettyPrint": "Auto pretty print",
          "raw": "Raw value",
          "markdown": "Markdown",
          "json": "JSON",
          "xml": "XML",
          "html": "HTML"
        }
      },
      "codeRenderer": {
        "placeholder": {
          "failedToFormatValue": "Error: Failed to format value as {codeLanguage}. \\r\\n\\r\\n{message}"
        },
        "notification": {
          "unsupportedCodeLanguage": "Unsupported code language."
        }
      },
      "htmlRenderer": {
        "placeholder": {
          "failedToRenderHtml": "Error: Failed to render HTML. Value is not a string."
        }
      },
      "priceRenderer": {
        "title": "Price for sale",
        "label": {
          "priceInnerRecordHandling": "Price inner record handling"
        },
        "notification": {
          "invalidPricesObject": "Invalid prices object!"
        },
        "filter": {
          "label": {
            "priceId": "Price ID",
            "priceList": "Price list",
            "currency": "Currency",
            "innerRecordIds": "Inner record IDs"
          },
          "help": {
            "computePriceForSale": "No price for sale found. To compute price for sale, following constraints need to be present in the filter: `priceInPriceLists`, `priceInCurrency`.",
            "missingPriceListsAndCurrencyForPriceForSale": "To compute a price for sale for the filtered prices, select at least one price list and one currency.",
            "noPriceForSale": {
              "text": "No price for sale was computed for the filtered prices because {reason}.",
              "reason": {
                "noPrices": "there are no prices left for this filter",
                "noPriceLists": "no price lists are selected",
                "noCurrency": "no currency is selected",
                "tooManyCurrencies": "more than one currency is selected"
              }
            },
            "priceListOrder": "The order of selected price lists <em>defines the price listing ordering</em>.<br/>It also <em>defines priority</em> of price lists for price for sale computation."
          }
        },
        "price": {
          "label": {
            "priceId": "Price ID",
            "priceList": "Price list",
            "currency": "Currency",
            "innerRecordId": "Inner record ID",
            "sellable": "Sellable",
            "validity": "Validity",
            "priceWithoutTax": "Price without tax",
            "priceWithTax": "Price with tax",
            "taxRate": "Tax rate",
            "virtual": "Virtual"
          },
          "tooltip": {
            "sellablePrice": "This price is sellable.",
            "notSellablePrice": "This price is not sellable."
          },
          "help": {
            "priceForSale": "This price would be used as a price for sale if this filter were used in the main query.",
            "virtualPriceForSale": "This is a virtual price for sale computed based on this filter. The price is virtual because the entity has price inner record handling set to `SUM`, therefore, the price for sale is a sum of internally selected prices."
          }
        }
      },
      "referenceAttributeRenderer": {
        "button": {
          "openReference": "Open reference in new tab"
        }
      }
    }
  },
  "errorViewer": {
    "placeholder": {
      "noDetailsAvailable": "No details available."
    },
    "button": {
      "submitIssue": "Submit an issue"
    }
  },
  "evitaQLConsole": {
    "placeholder": {
      "writeQuery": "// Write your EvitaQL query for catalog {catalogName} here.\n",
      "results": "Results will be displayed here...",
      "emptyHistory": "Empty history"
    },
    "button": {
      "clearHistory": "Clear history"
    },
    "notification": {
      "failedToSaveQueryToHistory": "Failed to save query to history."
    }
  },
  "graphQLConsole": {
    "instanceType": {
      "system": "System",
      "data": "Data",
      "schema": "Schema"
    },
    "placeholder": {
      "writeQuery": "# Write your GraphQL query for catalog {catalogName} here.\n",
      "results": "Results will be displayed here...",
      "emptyHistory": "Empty history"
    },
    "button": {
      "instanceDetails": "GraphQL API instance details",
      "clearHistory": "Clear history"
    },
    "notification": {
      "failedToSaveQueryToHistory": "Failed to save query to history."
    }
  },
  "resultVisualizer": {
    "selector": {
      "label": {
        "query": "From",
        "data": "Visualise"
      }
    },
    "visualiser": {
      "placeholder": {
        "noQueries": "No queries to visualise",
        "noSelectedQuery": "Select query to visualise",
        "noSelectedData": "Select what to visualise"
      }
    },
    "facetStatisticsVisualiser": {
      "placeholder": {
        "noGroups": "No facet summary groups found."
      },
      "label": {
        "externalGroup": "External",
        "externalReference": "External"
      },
      "notification": {
        "primaryKeyCopiedToClipboard": "Primary key copied to clipboard.",
        "noPrimaryKeyProperty": "No primary key property was fetched."
      },
      "help": {
        "noPrimaryKeyProperty": "No `primaryKey` property or representative attributes were fetched.",
        "noGroupCountProperty": "No `count` property was fetched.",
        "groupCountProperty": "The total number of entities matching any facet from this group without user filter.",
        "externalGroup": "This is only a reference to an external entity that is managed by external system.",
        "noRequestedProperty": "The `requested` property was not fetched.",
        "noRepresentativeProperty": "No `primaryKey` property or representative attributes were fetched.",
        "zeroImpactMatchCount": "No entities would be returned if this facet was requested because no entity has combination of already requested facets plus this one.",
        "noTotalRecordCountProperty": "The `totalRecordCount` property was not found in neither `recordPage` nor `recordStrip`.",
        "totalRecordCountProperty": "The total number of entities matching the user filter.",
        "noImpactDifferenceProperty": "The `impact.difference` property was not found.",
        "impactDifferenceProperty": "The difference from the current number of entities matching the user filter if this facet was requested.",
        "noImpactMatchProperty": "The `impact.matchCount` property was not found.",
        "impactMatchProperty": "The total number of entities matching the user filter if this facet was requested.",
        "noCountProperty": "The `count` property was not found.",
        "countProperty": "The total number of entities matching this facet without the user filter.",
        "externalReference": "This is only a reference to an external entity that is managed by external system."
      }
    },
    "hierarchyVisualiser": {
      "placeholder": {
        "noHierarchies": "No hierarchies found."
      },
      "label": {
        "requested": "Requested",
        "unknown": "Unknown"
      },
      "notification": {
        "primaryKeyCopiedToClipboard": "Primary key copied to clipboard.",
        "noPrimaryKeyProperty": "No primary key property was fetched.",
        "parentPrimaryKeyCopiedToClipboard": "Parent primary key copied to clipboard.",
        "noParentPrimaryKeyProperty": "No parent primary key property was fetched."
      },
      "help": {
        "noRepresentativeProperty": "No `primaryKey` property or representative attributes were fetched.",
        "requestedEntity": "The entity representing this hierarchy node was filtered by `hierarchyWithin`.",
        "noChildrenCountProperty": "The `childrenCount` property was not found.",
        "childrenCountProperty": "The count of child hierarchy nodes that exist in the hierarchy tree below the given node; the count is correct regardless of whether the children themselves are requested/traversed by the constraint definition, and respects hierarchyOfReference settings for automatic removal of hierarchy nodes that would contain empty result set of queried entities (REMOVE_EMPTY).",
        "noQueriedEntityCountProperty": "The `queriedEntityCount` property was not found.",
        "queriedEntityCountProperty": "The total number of queried entities that will be returned if the current query is focused on this particular hierarchy node using the hierarchyWithin filter constraint (the possible refining constraint in the form of directRelation and excludingRoot is not taken into account).",
        "nodeCountProperty": "The number of actually fetched nodes.",
        "requestedNode": "An entity representing a hierarchy node in this tree that was filtered by `hierarchyWithin`."
      }
    },
    "histogram": {
      "placeholder": {
        "unknown": "unknown",
        "missingPropertiesForChart": "Missing properties: {properties}. Cannot render the chart.",
        "missingProperties": "Missing properties: {properties}.",
        "missingPropertiesForSimulatedRange": "Missing properties: {properties}. Cannot simulate the range.",
        "missingPropertiesForActualRange": "Missing properties {properties} for actual values. The range is only simulated from indexes."
      },
      "label": {
        "allBuckets": "All buckets",
        "requestedBuckets": "Requested buckets",
        "overallCount": "Overall count",
        "bucketIndex": "Bucket index",
        "occurrences": "Occurrences",
        "threshold": "Threshold",
        "wasRequested": "Was requested"
      },
      "help": {
        "noMinProperty": "No `min` property of the histogram was fetched.",
        "noOverallCountProperty": "No `overallCount` property of the histogram was fetched.",
        "noMaxProperty": "No `max` property of the histogram was fetched."
      }
    },
    "attributeHistogram": {
      "placeholder": {
        "noAttributeHistograms": "No attribute histograms found."
      }
    },
    "priceHistogram": {
      "placeholder": {
        "noPriceHistograms": "No price histogram found."
      }
    }
  },
  "schemaViewer": {
    "section": {
      "placeholder": {
        "noItemsForSearchedTerm": "No items found for searched term."
      },
      "label": {
        "filter": "Filter"
      },
      "flag": {
        "entitySchema": {
          "hierarchical": "hierarchical"
        },
        "attributeSchema": {
          "representative": "representative",
          "globallyUnique": "globally unique",
          "globallyUniquePerLocale": "globally unique per locale",
          "unique": "unique",
          "uniquePerLocale": "unique per locale",
          "filterable": "filterable",
          "sortable": "sortable",
          "localized": "localized",
          "nullable": "nullable"
        },
        "associatedDataSchema": {
          "localized": "localized",
          "nullable": "nullable"
        },
        "referenceSchema": {
          "external": "external",
          "indexed": "indexed",
          "faceted": "faceted"
        }
      }
    },
    "catalog": {
      "label": {
        "catalogId": "Catalog ID",
        "version": "Version",
        "description": "Description"
      }
    },
    "entities": {
      "title": "Entities"
    },
    "entity": {
      "label": {
        "version": "Version",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "locales": "Locales",
        "currencies": "Currencies",
        "generatedPrimaryKey": "Generated primary key",
        "hierarchical": "Hierarchical",
        "prices": "Prices",
        "indexedDecimalPlaces": "Indexed decimal places",
        "evolutionModes": "Evolution modes"
      }
    },
    "nameVariants": {
      "title": "Name variants",
      "prefixedTitle": "{prefix} name variants",
      "label": {
        "camelCase": "camelCase",
        "kebabCase": "kebab-case",
        "pascalCase": "PascalCase",
        "snakeCase": "snake_case",
        "upperSnakeCase": "UPPER_SNAKE_CASE"
      }
    },
    "attributes": {
      "title": "Attributes"
    },
    "attribute": {
      "placeholder": {
        "uniqueWithinCollection": "Within collection",
        "uniqueWithinLocaleOfCollection": "Within locale of collection",
        "globallyUniqueWithinCatalog": "Within catalog",
        "globallyUniqueWithinLocaleOfCatalog": "Within locale of catalog"
      },
      "label": {
        "type": "Type",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "representative": "Representative",
        "unique": "Unique",
        "globallyUnique": "Globally unique",
        "filterable": "Filterable",
        "sortable": "Sortable",
        "localized": "Localized",
        "nullable": "Nullable",
        "defaultValue": "Default value",
        "indexedDecimalPlaces": "Indexed decimal places"
      },
      "help": {
        "uniqueWithinCollection": "The attribute value must be unique among all the entities of the same collection.",
        "uniqueWithinLocaleOfCollection": "The localized attribute value must be unique among all values of the same locale among all the entities.",
        "globallyUniqueWithinCatalog": "The attribute value (either localized or non-localized) must be unique among all values among all the entities using this global attribute schema in the entire catalog.",
        "globallyUniqueWithinLocaleOfCatalog": "The localized attribute value must be unique among all values of the same locale among all the entities using this global attribute schema in the entire catalog.",
        "implicitlyFilterable": "The attribute is implicitly filterable because it is unique."
      }
    },
    "associatedData": {
      "title": "Associated data"
    },
    "associatedDatum": {
      "label": {
        "type": "Type",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "localized": "Localized",
        "nullable": "Nullable"
      }
    },
    "references": {
      "title": "References"
    },
    "reference": {
      "label": {
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "cardinality": "Cardinality",
        "referencedEntity": "Referenced entity",
        "referencedEntityManaged": "Referenced entity managed",
        "referencedGroup": "Referenced group",
        "referencedGroupManaged": "Referenced group managed",
        "indexed": "Indexed",
        "faceted": "Faceted",
        "referencedEntityNameVariants": "Referenced entity",
        "referencedGroupNameVariants": "Referenced group"
      }
    }
  },
  "serverStatus": {
    "toolbar": {
      "title": "Status"
    },
    "detail": {
      "flags": {
        "version": "version: {version}"
      },
      "stats": {
        "started": "Started: {started}",
        "uptime": "Uptime: {uptime}",
        "catalogsOk": "Catalogs: {catalogCount}",
        "catalogsCorrupted": "Corrupted catalogs: {catalogCount}"
      },
      "actions": {
        "openRuntimeConfiguration": "Open runtime configuration"
      },
      "runtimeConfig": {
        "title": "Runtime configuration"
      }
    }
  },
  "backupViewer": {
    "path": "Backups",
    "button": {
      "backupCatalog": "Backup catalog"
    },
    "tasks": {
      "title": "Backups in preparation"
    },
    "list": {
      "title": "Finished backups"
    },
    "notification": {
      "couldNotLoadBackupFiles": "Could not load backup files: {reason}",
      "couldNotDownloadBackupFile": "Could not download backup file {fileName}: {reason}"
    },
    "backup": {
      "title": "Backup catalog",
      "description": "Request a new backup for the {catalogName} catalog:",
      "info": "The back up process may take a while. Therefore it will be started asynchronously. You can find it’s progress and backup file to download in task listing.",
      "form": {
        "pastMoment": {
          "label": "Past moment",
          "validations": {
            "required": "Past moment is required."
          }
        },
        "includeWal": {
          "label": "Include WAL",
          "description": "Will apply all mutations from WAL during restoration resulting in the latest version of catalog"
        }
      },
      "button": {
        "backup": "Backup"
      },
      "notification": {
        "backupRequested": "A backup for the {catalogName} catalog requested.",
        "couldNotRequestBackup": "Could not request a backup for the {catalogName} catalog: {reason}"
      }
    },
    "restore": {
      "title": "Restore catalog",
      "description": "Restore the {fileName} backup file into catalog:",
      "info": "The restore process may take a while. Therefore, it will be started asynchronously. You can find it's progress in backups or tasks.",
      "button": {
        "restore": "Restore"
      },
      "form": {
        "catalogName": {
          "label": "Catalog name",
          "validations": {
            "required": "Catalog name is required.",
            "empty": "Catalog name is required.",
            "leadingTrailingWhiteSpace": "Catalog name cannot have leading or trailing whitespace characters.",
            "keyword": "Catalog name is same as a reserved keyword.",
            "format": "Catalog name doesn't match supported format.",
            "notAvailable": "Catalog with this name already exists."
          }
        }
      },
      "notification": {
        "restoreRequested": "A restoration of the {fileName} backup file has been requested.",
        "couldNotRestoreBackupFile": "Could not restore backup file {fileName}: {reason}"
      }
    }
  },
  "taskViewer": {
    "path": "Tasks",
    "tasksVisualizer": {
      "notification": {
        "couldNotLoadTaskStatuses": "Could not load task statuses: {reason}",
        "taskCancelled": "The {taskName} task has been cancelled.",
        "taskNotCancelled": "The {taskName} task has not been cancelled. Probably because it is already finished",
        "couldNotCancelTask": "Could not cancel the {taskName} task: {reason}"
      }
    }
  },
  "jfrViewer": {
    "path": "JFR Recordings",
    "button": {
      "startRecording": "Start recording"
    },
    "tasks": {
      "title": "Running recordings"
    },
    "list": {
      "title": "Finished recordings"
    },
    "notification": {
      "couldNotDownloadRecordingFile": "Could not download recording file {fileName}: {reason}"
    },
    "startRecording": {
      "title": "Start JFR recording",
      "info": "This will start recording process in background which will be active until you stop it manually. Note that there can be only one recording active at the same time.",
      "form": {
        "events": {
          "label": "Events to record",
          "validations": {
            "required": "Events are required."
          }
        }
      },
      "button": {
        "startRecording": "Start recording"
      },
      "notification": {
        "couldNotLoadEventTypes": "Could not load available event types for JFR recording: {reason}",
        "couldNotStartRecording": "Could not start JFR recording: {reason}",
        "recordingStarted": "JFR recording has been started.",
        "recordingNotStarted": "JFR recording has not been started."
      }
    },
    "stopRecording": {
      "title": "Stop JFR recording",
      "info": "This will stop the active recording process. The final recording will be available in the JFR recording listing.",
      "button": {
        "stopRecording": "Stop recording"
      },
      "notification": {
        "couldNotStopRecording": "Could not stop JFR recording: {reason}",
        "recordingStopped": "JFR recording has been stopped.",
        "recordingNotStopped": "JFR recording has not been stopped."
      }
    }
  }
}